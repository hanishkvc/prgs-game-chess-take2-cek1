
*************** 20131127_2206

If already Under CHECK
1.0 cb_findbest
1.1. initially evaluates current position/situation
1.2. If check identified flag is set(thro increment).
1.3. List of moves is generated.
1.4. moves_process is called
2.0. moves_process
2.1. Creates a new chessboard with the currently evaluatin move executed.
2.2. cb_findbest called.
3.0. cb_findbest
3.1. evaluates current position
3.2. if still in check flag is incremented
3.3. return telling Error, because the king is still in check.

If entering CHECK, on a new move 
1.0 cb_findbest
1.1. initially evaluates current position/situation
1.2. As no check - flag is Not set (or rather cleared)
1.3. List of moves is generated.
1.4. moves_process is called
2.0. moves_process
2.1. Creates a new chessboard with the currently evaluatin move executed.
2.2. cb_findbest called.
3.0. cb_findbest
3.1. evaluates current position
3.2. As check identified flag is set (thro increment)
3.3. HOWTO IDENTIFY this situation and return with error.

To differentiate between both, may be use curDepth field to return immidiately in 2nd case at 3.0
OR check who is supposed to move next and who is already undercheck and then decide whether to
continue or not.


****** 20131128_0211, 20131129_0243

* Convert the moves being added to sMoves using 2longnot
* Have to add a hash table of seen chess position and evaluation.
* DONE: Add other missing piece moves.
  TODO: Add Special moves like Pawn promotion, Castling and EnPassant.
* DONE: Add logic for diagonal attack cross check.
* May be reduce the points given to indirect attack and protection
  i.e those attacks which are currently blocked, but can get
  activated due to movement of inbetween pieces.
  OR NOT, still not decided. TAKE A CALL after all other features
  have been added and the emergent behaviour checked.
* Update the Eval logics such that they identify true attack
  and protection situations and give more points to them 
  compared to indirect attacks and protections.
* Create a structure for individual moves. ANd use it instead
  of the current string based notation for all engine internal
  purposes.
* Wrt findbest, may be maintain the best and worst move for a given
  position rather than the current best only logic.
  Also may be update the selection logic such that, it selects a
  move which in turn leads to a almost equal best/good move,
  which at the same time keeps the worst score for the selected
  move minimal, if possible.
  i.e let us say if M1 can give best score of 800 and worst of
  200 (depending on what move the opponent plays), while M2 can
  give a best score of 750 and worst of 700, then may be M2 is
  better than M1. (However current logic will select M1 over
  M2 - So this may require to change).
  * May be later add logic to maintain more than 1 best and worst
    moves.
* once the findbest has selected a move, if it is a pawn promotion
  move then may be call findbest again with the choices of the
  pawn becoming a queen,rook,knight,bishop and see which gives
  the best result with a decent search depth. And use this info
  to decide what pawn promotion to use.
* Have to cross check how the findbest depth search and its unwinding 
  is actually playing out. And then may be update the eval returned
  logic for current position such that it gives weightage to the
  standalone eval value of the current position has well as the
  values returned by depth search from that position. -- TOTHINK

  i.e returned eval value of findbest =>
    StandAloneEval+DepthSearchEval.
    OR
    StandAloneEval*0.5+DepthSearchEval
    OR
   
  OR is this redundant and doesn't matter (TOTHINK TOTHINK)
 
* Have to check all eval return values to see it properly matchs
  the WhitePerspective or the SideToMove perspective as required.

* move_process may be a good candidate for multithreading. i.e
  multiple threads can be started which parallely process a
  different possible move for the current board position/situation.

* Increase the depth of search from the current 3 to 4 or 5 and
  see the change in behaviour if any (ideally there should be)
  as well as when the depth is changed to say 10 or 20 or 30 or 50.
  However deeper the depth, lot lot more time the engine will
  take as of now, as there is no Hash based logic to identify
  already seen positions and short circuit the remaining
  depth search.

****** 20131203

* A run with depth of 3 usually takes between few seconds to around 
  50 to 60 seconds.

* A run with depth of 5 takes around 1800-2500 seconds (i.e guessing).
  1918.26 seconds.
  6461K nodes(moves) in Total
  3Kn/sec.

  i.e something like 23 moves per position and inturn 23**5 = 6436343 
  and takes around 30 to 35 minutes to find the best move.

  EXTRAPOLATING from this to a depth of 6, it will have around 148M 
  nodes in Total (i.e 23**6). And may be around 12 hours or so to find 
  the best move.

* Depth 5
  1975.42 seconds
  Nodes 5087K
  3Kn/sec

* HashTable based version
  Depth 5
  1020 seconds
  Nodes 2000K
  3Kn/sec
