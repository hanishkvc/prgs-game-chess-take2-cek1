
*************** 20131127_2206

If already Under CHECK
1.0 cb_findbest
1.1. initially evaluates current position/situation
1.2. If check identified flag is set(thro increment).
1.3. List of moves is generated.
1.4. moves_process is called
2.0. moves_process
2.1. Creates a new chessboard with the currently evaluatin move executed.
2.2. cb_findbest called.
3.0. cb_findbest
3.1. evaluates current position
3.2. if still in check flag is incremented
3.3. return telling Error, because the king is still in check.

If entering CHECK, on a new move 
1.0 cb_findbest
1.1. initially evaluates current position/situation
1.2. As no check - flag is Not set (or rather cleared)
1.3. List of moves is generated.
1.4. moves_process is called
2.0. moves_process
2.1. Creates a new chessboard with the currently evaluatin move executed.
2.2. cb_findbest called.
3.0. cb_findbest
3.1. evaluates current position
3.2. As check identified flag is set (thro increment)
3.3. HOWTO IDENTIFY this situation and return with error.

To differentiate between both, may be use curDepth field to return immidiately in 2nd case at 3.0
OR check who is supposed to move next and who is already undercheck and then decide whether to
continue or not.


****** 20131128_0211, 20131129_0243

* Convert the moves being added to sMoves using 2longnot
* Have to add a hash table of seen chess position and evaluation.
* DONE: Add other missing piece moves.
  TODO: Add Special moves like Pawn promotion, Castling and EnPassant.
* DONE: Add logic for diagonal attack cross check.
* May be reduce the points given to indirect attack and protection
  i.e those attacks which are currently blocked, but can get
  activated due to movement of inbetween pieces.
  OR NOT, still not decided. TAKE A CALL after all other features
  have been added and the emergent behaviour checked.
* Update the Eval logics such that they identify true attack
  and protection situations and give more points to them 
  compared to indirect attacks and protections.
* Create a structure for individual moves. ANd use it instead
  of the current string based notation for all engine internal
  purposes.
* Wrt findbest, may be maintain the best and worst move for a given
  position rather than the current best only logic.
  Also may be update the selection logic such that, it selects a
  move which in turn leads to a almost equal best/good move,
  which at the same time keeps the worst score for the selected
  move minimal, if possible.
  i.e let us say if M1 can give best score of 800 and worst of
  200 (depending on what move the opponent plays), while M2 can
  give a best score of 750 and worst of 700, then may be M2 is
  better than M1. (However current logic will select M1 over
  M2 - So this may require to change).
  * May be later add logic to maintain more than 1 best and worst
    moves.
* once the findbest has selected a move, if it is a pawn promotion
  move then may be call findbest again with the choices of the
  pawn becoming a queen,rook,knight,bishop and see which gives
  the best result with a decent search depth. And use this info
  to decide what pawn promotion to use.
* Have to cross check how the findbest depth search and its unwinding 
  is actually playing out. And then may be update the eval returned
  logic for current position such that it gives weightage to the
  standalone eval value of the current position has well as the
  values returned by depth search from that position. -- TOTHINK

  i.e returned eval value of findbest =>
    StandAloneEval+DepthSearchEval.
    OR
    StandAloneEval*0.5+DepthSearchEval
    OR
   
  OR is this redundant and doesn't matter (TOTHINK TOTHINK)
 
* Have to check all eval return values to see it properly matchs
  the WhitePerspective or the SideToMove perspective as required.

* move_process may be a good candidate for multithreading. i.e
  multiple threads can be started which parallely process a
  different possible move for the current board position/situation.

* Increase the depth of search from the current 3 to 4 or 5 and
  see the change in behaviour if any (ideally there should be)
  as well as when the depth is changed to say 10 or 20 or 30 or 50.
  However deeper the depth, lot lot more time the engine will
  take as of now, as there is no Hash based logic to identify
  already seen positions and short circuit the remaining
  depth search.

****** 20131203

* A run with depth of 3 usually takes between few seconds to around 
  50 to 60 seconds.

* A run with depth of 5 takes around 1800-2500 seconds (i.e guessing).
  1918.26 seconds.
  6461K nodes(moves) in Total
  3Kn/sec.

  i.e something like 23 moves per position and inturn 23**5 = 6436343 
  and takes around 30 to 35 minutes to find the best move.

  EXTRAPOLATING from this to a depth of 6, it will have around 148M 
  nodes in Total (i.e 23**6). And may be around 12 hours or so to find 
  the best move.

* Normal version (startpos)
  Depth 5
  1975.42 seconds
  Nodes 5087K
  3Kn/sec

* HashTable based version (startpos)
  Depth 5
  967.20 seconds
  Nodes 1769K
  2Kn/sec

****** 20131204

* HashTable based version (startpos) _0xxx
  Depth 5
  786.20 seconds
  Nodes 1769K
  2Kn/sec

* HashTable based version (startpos) _17xx
  Depth 5
  641.10 seconds
  Nodes 1769K
  3Kn/sec

* HashTable based version (startpos) _1953 
  (eval_tANDp updated for Direct and Indirect)
  Depth 5
  667.24 seconds
  Nodes 1769K
  3Kn/sec

****** 20131205

* The Eval logic was giving equal or almost similar weightage to 
  protection_provided compared to threats_given So the combined 
  effect was that in situations where the logic should have 
  attacked a opponent piece, instead it was moving pieces around 
  which gives it a percieved better eval because it inturn was 
  giving a  large protection value.

  HOWEVER 
  1. as currently the logic doesn't calibrate the protection value 
     looking at the attacks on the given peice i.e before deciding 
     how much weightage to give to that protection.
 
  2. And also as a piece under a single attack requires 2 pieces 
     protecting it in the worst case and 1 more protecting piece
     than the number of opposing attacking pieces. 

  The weightage has been tuned such that protection weightage is
  only half of the threat weightage.
 
* HashTable based version with rebalanced weightages (startpos) 
  (eval_tANDp updated for Direct and Indirect)
  Depth 5
  248.06 seconds
  Nodes 1769K
  7Kn/sec

TODO:NEXT:
* Add support for pawn promotion. After thinking thro it
  rather than adding it at the end of findbest during
  unwinding. Better to add it during move generation
  for pawns, if it is found that the pawn will go into
  the final rank on the opposite side. So automatically
  the remaining calculations will kick in wrt finding
  the right candidate move of pawn promotion for the 
  given position.
  
  NOTE: If added at unwind time, one would have had to 
  call the findbest again there as a special case to find
  which of the 4 possible pawn promotion possibilities
  would have been the best one.

* Also check how castle info is passed thro and add
  support for same.

* Maybe add a mixed depth search logic, where
  First N steps of the depth, do a full search
  over all the valid moves and for depths beyond
  that N, do a selective depth search for another
  M steps.
  This selective depth search, will only select
  few of the most/more positive, 
  few of the most/more negative and 
  few of the inbetween/middle (~0) moves.
  May be between 6 to 9 moves.

  i.e say (20-40)**5+9**6+3**12

* Use tsearch or hsearch or equivalent for HashTables
  and inturn see the performance impact if any


